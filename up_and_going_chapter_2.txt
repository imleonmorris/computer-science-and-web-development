1. Values & Types
2. Objects
    a. Arrays
    b. Functions
3. Built-In Type Methods
4. Comparing Values
    a. Coercion
    b. Truthy & Falsy
    c. Equality
    d. Inequality
5. Variables
6. Function Scopes
    a. Hoisting
    b. Nested scopes
7. Conditionals
8. Strict Mode
9. Functions as Values
10. Immediately Invoked Function Expressions (IIFEs)
11. Closure
    a. Modules
12. this Identifier
13. Prototypes
14. Old & New
15. Polyfilling
16. Transpiling
17. Non-JavaScript

// Values and Types

    1. string
    2. number
    3. boolean
    4. null and undefined
    5. object
    6. symbol (new)

    -> use the typeof operator to examine a value's type. Always returns a string value.

    var a;
    typeof a;       // "undefined"

    a = "hello world";
    typeof a;       // "string"

    a = 42;
    typeof a;       // "number"

    a = true;
    typeof a;       // "boolean"

    a = null;
    typeof a;       // "object"--weird, bug

    a = undefined;
    typeof a;       // "undefined"

    a = { b: "c"};
    typeof a;       // "object"

// Objects

    var obj = {
        a: "hello world",
        b: 42,
        c: true
    };

    obj.a;  // "hello world"
    obj.b;  // 42
    obj.c;  // true

    obj["a"];   // "hello world"
    obj["b"];   // 42
    obj["c"];   // true

    -> these properties can be accessed using:
        1. dot notation
        2. bracket notation (such properties known as keys)

    // a. Arrays

    -> holds values in numerically indexed positions.

    var arr = [
        "hello world",
        42,
        true
    ];

    arr[0];     // "hello world"
    arr[1];     // 42
    arr[2];     // true
    arr.length; // 3

    tyeof arr;  // "object"

    // b. Functions

    function foo() {
        return 42;
    }

    foo.bar = "hello world";

    typeof foo;         // "function"
    typeof foo();       // "number"
    typeof foo.bar;     // "string"

// Built-In Type Methods

    ??

// Comparing Values

    // a. Coercion

    -> Explicit

        var a = "42";

        var b = Number( a );

        a;      // "42"
        b;      // 42--the number!

    -> Implicit

        var a = "42";

        var b = a * 1;  // "42" implicitly coerced to 42 here

        a;      // "42"
        b;      // 42 -- the number!


    // b. Truth & falsy

    These are falsy"
    -> "" (empty string)
    -> 0, -0, NaN (invalid Number)
    -> null, undefined
    -> false

    *Everything else is truthy*

    // c. Equality

    1. == (value equality w/ coercion)
    2. === (value & type equality w/out coercion)
    3. !=
    4. !==

        var a = "42";
        var b = 42;

        a == b;         // true
        a === b;        // false

        But how is this coerced? Either:

        42 == 42 OR "42" == "42"

        But which?
        --> It's 42 == 42

        It may not matter how it gets there with such a simple example, but it does matter later on.

        Many opt to use === as it is more predictable but author believes this is short sighted.

        Learn the rules here (11.9.3): http://www.ecma-international.org/ecma-262/5.1/

        However, two tips to avoid ==:
        -> If either value (side) could be the true or false value
        -> If either value (side) could be:
            a. 0
            b. ""
            c. []

        * It is safe to use == in all other case*

        -> Objects check matching references and not the underlying values.
        -> Arrays are default coerced to strings by joining all the values with commas.

        var a = [1,2,3];
        var b = [1,2,3];
        var c = "1,2,3";

        a == c;     // true
        b == c;     // true
        a == b;     // false

    // d. Inequality (relational comparison)

        1. <
        2. >
        3. <=
        4. >=

    Coercion works in a similar way as before.

    var a = 41;
    var b = "42";
    var c = "43";

    a < b;      // true
    b < c;      // true

    -> NB: what is happening is simple:
    1. If both values are string, no coercion.
    2. If one is not, then coerce both to numbers.

    Consider:

    var a = 42;
    var b = "foo";

    a < b;      // false
    a > b;      // false
    a == b;     // false

    1. The first two show as false as b is being converted to NaN (and NaN is neither greater than nor less than any other value)
    2. The third fails as it is 42 == NaN.

// Variables

-> var names must be valid identifiers. There are strict rules.

    1. must start with:
        - a-z,
        - A-Z,
        - $,
        - _
    2. cannoto use reserved words:
        - for
        - in
        - if
        - null
        - true
        - false
        - etc

    [see appendix A for more]

// Function Scopes

    // Hoisting

    -> When a var appears inside a scope, and belongs to the entire scope (being accessible throughout) - this is known as hoisting.

    var a = 2;

    foo();          // works because 'foo()'
                    // declaration is hoisted

    function foo() {
        a = 3;

        console.log( a );      // 3

        var a;              // declaration is "hoisted"
                            // to the top of 'foo()'
    }

    console.log( a );       // 2

    // Nested Scopes

        -> Always formally declare vars otherwise it will be global! (bad leon)
        -> A var declared will be accessible all the way down into nested functions
        -> but not the other way!

        -> Use the let keyword at function level to declare vars for individual blocks.

        function foo() {
            var a = 1;

            if (a >= 1) {
                let b = 2;

                while (b < 5) {
                    let c = b * 2;
                    b ++;

                    console.log( a + c );
                }
            }
        }

        foo();
        // 5 7 9

// Conditionals

-> 1. Can supplement if..else statements with else if.
-> 2. Can also use a switch statement

switch (a) {
    case 2:
        // do something
        break;
    case 10:
        // do another thing
        break;
    case 42:
        // do yet another thing
        break;
    default:
        // fallback to here
}

-> The break is important otherwise you get fall through. This is sometimes desired however, as it means you can get two cases executing the same code.

-> 3. Ternary Operator

This is a bit like a if..else statement:

var a = 42;

var b = (a > 41) ? "hello" : "world";

similar to:

if (a > 41) {
    b = "hello";
} else {
    b = "world";
}

// Strict mode

If "use strict"; works in a similar way to scope.

-> Strict mode disallows the auto-global var declaration:

function foo() {
    "use strict";
    a = 1;          // 'var' missing, ReferenceError
}

foo();

-> If stict mode starts making your code buggy, clearly there are things to fix.

// Functions as Values

    This is the syntax of a function:

    function foo() {
        // ..
    }

-> foo is another var. The function itself can be a value.
-> functions expressions can be:
    - anonymous
    - named

Anon:

var foo = function() {
    // ..
}

var x = function bar () {
    // ..
}

-> named function expressions are more preferable.

// IIFEs

-> In the previous section, neither are executed. But we could.
-> because IIFEs also have variable scope, they can declare vars which won't affect surrounding code:

var a = 42;

(function IIFE() {
    var a = 10;
    console.log( a );   // 10
})();

console.log( a );       // 42

-> IIFEs can also have return values:

var x = (function IIFE() {
    return 42;
})();

x;      // 42

// Closure

    -> most important thing to learn.
    -> think: way to 'remember' & continue to access a function's scope even once the function has finished running.

    function makeAdder(x) {
        // parameter 'x' is an inner var

        // inner function 'add()' uses 'x', so
        // it has a "closure" over it
        function add(y) {
            return y + x;
        };

        return add;
    }

    ????

// Modules

??

// this Identifier

-> usually points to an object. However, which object depends on how the function is called.
-> NB: does not reference the function itself.

    function foo() {
        console.log( this.bar );
    }

    var bar = "global";

    var obj1 = {
        bar: "obj1",
        foor: foo
    };

    var obj2 = {
        bar = "obj2"
    };

    // -------------------------------------

    foo ();                 // "global"
    obj1.foo();             // "obj1"
    foo.call( obj2 );       // "obj2"
    new foo();              // undefined

    -> There are four rules:

        1. foo() ends up setting this to the global object (in non-strict mode). In stict mode, this would be undefined.
        2. obj1.foo() sets this to the obj1 object.
        3. foo.call(obj2) sets this to the obj2 object.
        4. new foo() sets this to a brand new empty object.

